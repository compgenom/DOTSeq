---
title: "DOTSeq: Detecting Differential ORF Usage in Ribosome Profiling Data"
author: 
- name: "Chun Shen Lim"
  affiliation: |
    Department of Biochemistry, Faculty of Biomedical Sciences, 
    University of Otago, Dunedin, New Zealand.
- name: "Gabrielle S.W. Chieng"
  affiliation: |
    Department of Biochemistry, Faculty of Biomedical Sciences, 
    University of Otago, Dunedin, New Zealand.
output:
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::pdf_document: default
vignette: >
  %\VignetteIndexEntry{DOTSeq}  
  %\VignetteEngine{knitr::rmarkdown}  
  %\VignetteEncoding{UTF-8}
package: DOTSeq
bibliography: DOTSeq.bib
---

# Introduction
`DOTSeq` is an R package for detecting differential translation of open 
reading frames (ORFs) from ribosome profiling (Ribo-seq) 
[@ingolia2009genome, @ingolia2019ribosome] and matched RNA-seq datasets 
[@lim2025differential]. Translation is a tightly regulated process, 
where multiple ORFs within the same gene can modulate protein synthesis. 
Traditional gene-level approaches obscure these regulatory layers. 
`DOTSeq` addresses this limitation by modelling translation at the ORF 
level.

`DOTSeq` provides two complementary modules:

- **Differential ORF Usage (DOU)**: Detects *cis*-translational regulation 
by testing whether the relative usage of ORFs within a gene changes across 
biological conditions. Implemented via a beta-binomial generalised linear 
model (GLM) (`glmmTMB`) [@RJ-2017-066].

- **Differential Translation Efficiency (DTE)**: Tests for changes in 
ribosome occupancy relative to RNA abundance across conditions using a 
negative-binomial GLM (`DESeq2`) [@love2014moderated].

Together, **DOU** and **DTE** modules allow global identification of 
translation-specific effects, revealing regulatory events such as 
uORF-mediated repression.

# Load required library
We start by loading the `DOTSeq` package and its dependencies. 
`DOTSeq` builds on the Bioconductor ecosystem, particularly the 
`SummarizedExperiment` container for storing count matrices and 
metadata.

```{r setup, warning=FALSE}
library(DOTSeq, quietly = TRUE)
library(SummarizedExperiment, quietly = TRUE)
```

# Example dataset
We demonstrate `DOTSeq` functionalities using a HeLa cell cycle dataset 
[@ly2024nuclear]. This dataset includes the snapshots of translation 
landscapes in HeLa cells synchronised at Mitotic Cycling, Mitotic Arrest, 
and Interphase. Each condition contains two biological replicates. 

Here, we use only a small portion of the dataset to speed up the 
vignette execution while still demonstrating all key functionalities.

```{r dir}
dir <- system.file("extdata", package = "DOTSeq")
list.files(dir)
```

# Input data
Ribo-seq and RNA-seq reads are preprocessed using standard pipelines. 
Reads were adapter-trimmed using Cutadapt [@martin2011cutadapt], aligned 
to the reference genome using STAR [@dobin2013star], and summarised at the 
ORF level using featureCounts [@liao2014featurecounts]. 

Each row of the input count matrix corresponds to an ORF, while columns 
contain read counts for individual samples. The first six columns 
represent ORF-level annotation fields such as gene ID, transcript ID, 
chromosome, and coordinates. This ensures accurate mapping between 
read counts and annotated ORFs, which is critical for our analysis.

```{r read-in-count-file}
cnt <- read.table(
    file.path(dir, "featureCounts.cell_cycle_subset.txt.gz"), 
    header = TRUE, 
    comment.char = "#"
)
names(cnt) <- gsub(".*(SRR[0-9]+).*", "\\1", names(cnt))
head(cnt)
```

# ORF annotation files 
Flattened ORF-level annotations were generated using the orf_to_gtf.py 
wrapper from RIBOSS [@lim2025riboss]. This pre-processing step ensures 
that each ORF occupies a distinct, non-overlapping genomic interval, 
avoiding ambiguity when assigning reads. This design follows the same 
logic as `DEXSeq`'s exon flattening, but at the level of ORFs rather 
than exons [@anders2012detecting].

```{r ref}
flat <- file.path(dir, "gencode.v47.orf_flattened_subset.gtf.gz")
bed <- file.path(dir, "gencode.v47.orf_flattened_subset.bed.gz")
```

# Prepare condition table
The condition table defines the experimental design for both Ribo-seq and 
RNA-seq samples. It allows `DOTSeq` to match Ribo/RNA-seq pairs and to 
model translation-specific interactions. 

Each row corresponds to one sequencing run. The table must include four 
essential columns: run, strategy (`"ribo"` or `"rna"`, or `"0"` or `"1"`), 
replicate, and condition. Additional columns (e.g., batch) can also be 
included.

```{r condition-table}
meta <- read.table(file.path(dir, "metadata.txt.gz"))
names(meta) <- c("run", "strategy", "replicate", "treatment", "condition")
head(meta)
```

Here we restrict the analysis to samples pre-treated with cycloheximide 
(chx) before library preparation.

```{r extract-chx}
cond <- meta[meta$treatment == "chx", ]
```

# Run DOTSeq
The main function `DOTSeq()` performs the differential analysis workflow, 
starting from parsing count and annotation files to post hoc inference. 
`DOTSeq()` is a wrapper function that runs the three key sequential steps 
below.  

- Construction of two `SummarizedExperiment` objects (`DOTSeqDataSet()`).

- model fitting of DOU (`glmmTMB` beta-binomial GLM via `fitDOU()`) and DTE 
(negative-binomial GLM via `DESeq2`).

- Post hoc contrasts and adaptive shrinkage of effect sizes via `emmeans` 
[@emmeans] and `ashr` (`testDOU()`). 

`DOTSeqDataSet()`, `fitDOU()`, and `testDOU()` can be ran individually. 
For simplicity, here we will use the `DOTSeq()` main function. To capturing 
the translation-specific interaction effect ($\beta_{\text{int}}$), 
`DOTSeq()` uses the conditional `formula = ~ condition * strategy` with 
`dispersion_modeling = "auto"` by default. The conditional and dispersion 
formulas can be customised to include batch and random effects.

```{r dotseq, warning=FALSE}
m <- DOTSeq(
    count_table = cnt,
    condition_table = cond,
    flattened_gtf = flat,
    bed = bed
)
```

In this case Interphase was automatically assigned as the baseline. The target 
and baseline conditions can explicitly defined as `target = "Mitotic_Cycling"` 
and `baseline = "Interphase"`.

# Inspect results
The output of `DOTSeq()` is a list containing two main objects:

- sumExp: DOU results (beta-binomial GLMs).

- dds: DTE results (negative binomial GLMs).

```{r dotseq-objects}
names(m)
```

Each of these objects includes model fit results and post hoc summaries.
For example, we can extract the post hoc contrast results stored in 
the metadata:

```{r posthoc}
dou_results <- metadata(m$sumExp)$interaction_results
dte_results <- metadata(m$dds)$interaction_results
```

These data frames summarise differential translation results for each ORF. 
Key statistics include:

- `PosteriorMean`: The shrunken log-odds fold change in ORF usage (DOU), 
reflecting the estimated effect size after empirical Bayes shrinkage.

- `lfsr` (Local False Sign Rate): The probability that the estimated effect 
has the wrong sign, providing a measure of directional uncertainty.

- `log2FoldChange`: The shrunken log2 fold change in ORF translation 
efficiency (DTE), indicating relative changes in ribosome loading.

- `padj`: The adjusted p-value for DTE, accounting for multiple testing.

Additional statistics for DOU results include:

- `betahat`: The raw (unshrunken) effect size estimate.

- `sebetahat`: The standard error of the raw estimate.

- `qvalue` and `lfdr` (Local False Discovery Rate): Alternative measures 
of significance and false discovery, also computed by `ashr`.

- `WaldP` and `WaldPadj`: Wald test results are included for completeness, 
providing frequentist estimates of significance.

```{r dou}
dou_results
```

The DTE effect size (`log2FoldChange`) was derived from 
`DESeq2::lfcShrink()` within the `DOTSeq()` main function. We specify 
`type = ashr` to apply adaptive shrinkage and compute all pairwise 
contrasts between conditions. 

```{r dte}
dte_results
```

We can also inspect the `rowData` and `rowRanges` of the 
`SummarizedExperiment` objects to explore ORF level annotation. This 
includes mappings from gene to transcript to ORF IDs, as well as `orf_type`, 
which currently supports uORF, mORF, and dORF. Filtering criteria 
`count_filter` and `singlet_filter` determine whether an ORF is retained 
(`is_kept`) for model fitting. `DOUResults` stores the model fit 
results and the `emmeans` objects for post hoc contrasts.

```{r rowdata}
rowData(m$sumExp)
```

The `rowRanges` slot retains the genomic coordinates corresponding to ORFs, 
extending from the translational start (AUG) to stop codons. These ranges 
may include intronic regions, depending on the gene structures.

```{r rowranges}
rowRanges(m$sumExp)
```

# Visualisation
`DOTSeq` provides the `plotDOT()` function for visualising DOU and DTE 
results. The following plots can be generated:

```{r merge}
dou_mci <- dou_results[dou_results$contrast == "Mitotic_Cycling - Interphase", ]
dte_mci <- dte_results[dte_results$contrast == "Mitotic_Cycling - Interphase", ]

results <- merge(dou_mci, dte_mci, by = c("orf_id", "contrast"), all = TRUE)
```

## Venn diagram: 
To explore the relationship between DOU and DTE, we can visualise the 
overlap between significant ORFs identified by each module. ORFs that 
are significant in **DOU** and **DTE** analyses suggest changes in both 
usage and translation efficiency, potentially indicating strong 
translational control.

```{r plot-venn, eval = requireNamespace("eulerr", quietly = TRUE), fig.small = TRUE}
if (requireNamespace("eulerr", quietly = TRUE)) {
    plotDOT(results = results, plot_types = "venn", force_new_device = FALSE)
} else { 
    message("Package 'eulerr' not installed; skipping Venn diagram.")
}
```

## Composite scatter plot: 
To compare DOU and DTE, we generate a composite scatter plot of their 
respective effect sizes. Marginal density plots along each axis 
illustrate the distribution of effect sizes for each metric. Spearman 
correlation is calculated and reported. 

For this scatter plot, points are colour-coded by significance, 
allowing us to identify ORFs with strong effects in one analysis but 
weak in the other. This visualisation helps highlight patterns of 
differential translation across ORFs. 

```{r plot-composite-by-significance, fig.small = TRUE}
plotDOT(results = results, plot_types = "composite", force_new_device = FALSE)
```

If `rowdata` is given as an input, points can also be colour-coded by 
`orf_type`. This enables quick identification of patterns in differential 
translation across different ORF types.

```{r plot-composite-by-orfs, fig.small = TRUE}
rowdata <- rowData(m$sumExp)
plotDOT(
    results = results, 
    rowdata = rowdata, 
    plot_types = "composite", 
    force_new_device = FALSE
)
```

## Volcano plot: 
To highlight ORFs with strong differential usage, we construct a volcano 
plot comparing significance versus DOU effect size.

By default, gene identifiers are mapped from Ensembl gene IDs to HGNC 
gene symbols using `biomaRt` This mapping improves plot readability by 
displaying gene symbols. The resulting ID mapping dataframe can be 
stored as a dataframe and reused across plots to avoid repeated downloads.

```{r plot-volcano-by-significance, fig.small = TRUE}
id_mapping <- plotDOT(
    results = results,
    plot_types = "volcano",
    volcano_legend_position = "topright",
    force_new_device = FALSE
)
```

Similarly, volcano plots can be colour-coded by significance or ORF types, 
depending on whether rowdata is given as an input. 

```{r plot-volcano-by-orfs, fig.small = TRUE}
plotDOT(
    results = results,
    rowdata = rowdata,
    id_mapping = id_mapping,
    plot_types = "volcano", 
    volcano_legend_position = "topright",
    force_new_device = FALSE
)
```

## Heatmap: 
To visualise the top-ranked genes, we generate a heatmap based on DOU 
metrics for the top 20 uORF-regulated genes. 

```{r plot-heatmap, warning=FALSE, fig.width=4, fig.height=8, fig.align="center", out.width="325px"}
plotDOT(
    results = results, 
    rowdata = rowdata, 
    id_mapping = id_mapping, 
    plot_types = "heatmap", 
    top_genes = 20,
    force_new_device = FALSE
)
```
# Simulation and benchmarking

`DOTSeq` includes the function `simDOT()` for generating simulated Ribo-seq 
and RNA-seq count matrices. It enables benchmarking under controlled 
scenarios with configurable effect sizes, batch effects, and ORF types. 

Simulations in our manuscript [@lim2025differential] show that:

- The **DOU** module performs well at low-to-moderate effect sizes on 
DOU-type scenarios. This module is specifically designed to detect 
condition-dependent shifts in the expected proportion of Ribo-seq to 
RNA-seq counts for individual ORFs relative to other ORFs within the 
same gene (i.e., changes in ORF usage). This module targets 
*cis*-regulatory usage changes that alter relative ORF proportions 
within genes.

- The **DTE** module performs better at large-magnitude changes in 
translation efficiency. This module captures ORF-level changes in ribosome 
occupancy relative to RNA abundance.

# Summary

`DOTSeq` offers a unified framework for modelling translational control at 
the ORF level. `DOTSeq` has two modules capturing distinct biological 
signals: **DOU** tests for shifts in relative usage within genes 
(*cis*-regulation), whereas **DTE** tests for changes in per-ORF translation 
efficiency relative to transcript abundance. They can be used together to 
provide a fuller picture of translational regulation.

# References

# Session info
```{r sessionInfo}
sessionInfo()
```

