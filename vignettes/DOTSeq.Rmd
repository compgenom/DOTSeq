---
title: "DOTSeq: Detecting Differential ORF Usage in Ribosome Profiling Data"
author: 
- name: "Chun Shen Lim"
  affiliation: |
    Department of Biochemistry, Faculty of Biomedical Sciences, 
    University of Otago, Dunedin, New Zealand.
- name: "Gabrielle S.W. Chieng"
  affiliation: |
    Department of Biochemistry, Faculty of Biomedical Sciences, 
    University of Otago, Dunedin, New Zealand.
output:
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::pdf_document: default
vignette: >
  %\VignetteIndexEntry{DOTSeq}  
  %\VignetteEngine{knitr::rmarkdown}  
  %\VignetteEncoding{UTF-8}
package: DOTSeq
bibliography: DOTSeq.bib
---

# Introduction
DOTSeq is an R package for detecting differential translation of open 
reading frames (ORFs) from matched ribosome Profiling (Ribo-seq) and 
RNA-seq datasets [@lim2025differential]. Translation is a tightly 
regulated process, where multiple ORFs within the same gene can modulate 
protein synthesis. Traditional gene-level approaches obscure these 
regulatory layers. DOTSeq addresses this limitation by modelling 
translation at the ORF level.

DOTSeq provides two complementary modules:

- **Differential ORF Usage (DOU)**: Detects *cis*-translational regulation 
by testing whether the relative usage of ORFs within a gene changes across 
biological conditions. Implemented via a beta-binomial GLM (`glmmTMB`) 
[@RJ-2017-066].

- **Differential Translation Efficiency (DTE)**: Tests for changes in 
ribosome occupancy relative to RNA abundance across conditions using a 
negative-binomial GLM (`DESeq2`) [@love2014moderated].

Together, **DOU** and **DTE** modules allow global identification of 
translation-specific effects, revealing regulatory events such as 
uORF-mediated repression.

# Load Required Library

```{r setup, warning=FALSE}
library(DOTSeq, quietly = TRUE)
library(SummarizedExperiment, quietly = TRUE)
```

# Example Dataset
We demonstrate DOTSeq functionalities using a cell cycle dataset 
[@ly2024nuclear], where translation initiation and elongation were profiled 
in HeLa cells synchronised at Mitotic Cycling, Mitotic Arrest, and 
Interphase. Each condition contains two biological replicates.

Raw sequencing reads are available at GEO accession number 
[GSE230189](http://www.ncbi.nlm.nih.gov/projects/geo/query/acc.cgi?acc=GSE230189).

```{r dir}
dir <- system.file("extdata", package = "DOTSeq")
list.files(dir)
```

# Input data
Ribo-seq and RNA-seq reads were adapter-trimmed using Cutadapt 
[@martin2011cutadapt], aligned to the reference genome using STAR 
[@dobin2013star], and summarised at the ORF level using featureCounts 
[@liao2014featurecounts]. Flattened ORF-level annotations were generated 
with the orf_to_gtf.py wrapper from RIBOSS [@lim2025riboss], analogous to 
DEXSeq’s exon-flattening procedure [@anders2012detecting].

DOTSeq requires a counts matrix formatted like the output from featureCounts, 
with the first six columns representing ORF-level annotations and the 
remaining columns containing sample counts. To speed up the vignette 
execution we will use a subset of input data. 

```{r read-in-count-file}
cnt <- read.table(
    file.path(dir, "featureCounts.cell_cycle_subset.txt.gz"), 
    header = TRUE, 
    comment.char = "#")
names(cnt) <- gsub(".*(SRR[0-9]+).*", "\\1", names(cnt))
head(cnt)
```

# ORF annotation files 
Flattening ensures discrete, non-overlapping ORF bins across transcript 
isoforms, allowing unambiguous assignment of Ribo-seq reads to ORFs.

```{r ref}
flat <- file.path(dir, "gencode.v47.orf_flattened_subset.gtf.gz")
bed <- file.path(dir, "gencode.v47.orf_flattened_subset.bed.gz")
```

# Prepare Condition Table
DOTSeq requires a condition table defining the experimental design for both 
Ribo-seq and RNA-seq samples.The table must include four essential columns:
run, strategy ("ribo" or "rna", or "0" or "1"), replicate, and condition.
Additional columns (e.g., batch) can also be included.

```{r condition-table}
meta <- read.table(file.path(dir, "metadata.txt.gz"))
names(meta) <- c("run", "strategy", "replicate", "treatment", "condition")
head(meta)
```

We will focus on Mitotic Cycling and Interphase, using samples pre-treated by 
cycloheximide (chx) shortly before harvesting.

```{r extract-chx}
cond <- meta[meta$treatment == "chx", ] # extract only samples processed using cyclohexamide
cond$treatment <- NULL # remove the treatment column
```

# Running DOTSeq
The main wrapper `DOTSeq()` performs three sequential steps:
- Construction of two SummarizedExperiment objects (`DOTSeqDataSet()`)
- model fitting of DOU (`glmmTMB` beta-binomial GLM via `fitDOU()`) and DTE 
(negative-binomial GLM via `DESeq2`).
- Post hoc contrasts and adaptive shrinkage of effect sizes via `emmeans` 
[@emmeans] and `ashr` (`testDOU()`). 

`DOTSeqDataSet()`, `fitDOU()`, and `testDOU()` can be ran separately. For 
simplicity, here we will use the `DOTSeq()` wrapper. To capturing the 
translation-specific interaction effect (β_int), `DOTSeq()` uses the 
conditional formula `~ condition * strategy` with 
`dispersion_modeling = "auto"` by default. The conditional and dispersion 
formulas can be customised to include batch and random effects.

```{r dotseq, warning=FALSE}
m <- DOTSeq(
    count_table = cnt,
    condition_table = cond,
    flattened_gtf = flat,
    bed = bed
)
```

In this case Interphase was automatically assigned as the baseline. The target 
and baseline conditions can explicitly defined as `target = "Mitotic_Cycling"` 
and `baseline = "Interphase"`.

# Accessing results
DOTSeq returns two main objects:

- sumExp: DOU results (beta-binomial GLMs)
- dds: DTE results (negative binomial GLMs)

```{r dotseq-objects}
names(m)
```

Post hoc results are stored in the metadata:

```{r posthoc}
dou_results <- metadata(m$sumExp)$interaction_results
dte_results <- metadata(m$dds)$interaction_results
```

Key metrics include:

- PosteriorMean - shrunk log-odds fold change (PosteriorMean) and
- lfsr - Local False Sign Rate (lfsr) for DOU
- log2FoldChange - shrunken log2-fold change and
- padj - adjusted p-value for DTE

PosteriorMean, lfsr and log2FoldChange were computed by `ashr`'s adaptive 
shrinkage estimator.

```{r dou}
dou_results
```

The DTE results were obtained from `lfcShrink()` within the `DOTSeq()` wrapper. 
We use `type = ashr` to compute all pairwise contrasts.

```{r dte}
dte_results
```

We can also inspect the `rowData` and `rowRanges` of the SummarizedExperiment 
objects with ORF level annotation. 

```{r rowdata}
rowdata <- rowData(m$sumExp)
rowdata
```

These ranges correspond to ORFs, extending from the translational start (AUG) 
to stop codons, and may include intronic regions.

```{r rowranges}
rowRanges(m$sumExp)
```

# Visualisation
DOTSeq provides the `plotDOT()` function for visualising DOU and DTE results.
The following plots can be generated:

```{r merge}
dou_mci <- dou_results[dou_results$contrast == "Mitotic_Cycling - Interphase", ]
dte_mci <- dte_results[dte_results$contrast == "Mitotic_Cycling - Interphase", ]

results <- merge(dou_mci, dte_mci, by = c("orf_id", "contrast"), all = TRUE)
```

## Venn diagram: 
Shows overlap between significant DOU and DTE ORFs.

```{r plot-venn, fig.small = TRUE}
plotDOT(results = results, plot_types = "venn", force_new_device = FALSE)
```

## Composite scatter plot: 
Compares DOU and DTE effect sizes with marginal density plots. Points are 
colour-coded by significance.

```{r plot-composite-by-significance, fig.small = TRUE}
plotDOT(results = results, plot_types = "composite", force_new_device = FALSE)
```

Points can be colour-coded by ORF types if rowdata is given as an input.

```{r plot-composite-by-orfs, fig.small = TRUE}
plotDOT(
    results = results, 
    rowdata = rowdata, 
    plot_types = "composite", 
    force_new_device = FALSE
)
```

## Volcano plot: 
Displays significance versus DOU effect size.

By default, generating these plots involve ID mapping from Ensembl gene IDs 
to HGNC gene symbols using `biomaRt`. This mapping helps make the plot more 
accessible by showing gene symbols. The resulting ID mapping dataframe can 
be stored for reuse in subsequent plots to avoid repeated downloads.

```{r plot-volcano-by-significance, fig.small = TRUE}
id_mapping <- plotDOT(
    results = results,
    plot_types = "volcano",
    force_new_device = FALSE
)
```

Similarly, volcano plots can be colour-coded by significance or ORF types, 
depending on whether rowdata is given as an input. 

```{r plot-volcano-by-orfs, fig.small = TRUE}
plotDOT(
    results = results,
    rowdata = rowdata,
    id_mapping = id_mapping,
    plot_types = "volcano", 
    force_new_device = FALSE
)
```

## Heatmap: 
Visualises the top ORFs or genes (e.g., top 40 uORF-regulated genes).

```{r plot-heatmap, warning=FALSE}
plotDOT(
    results = results, 
    rowdata = rowdata, 
    id_mapping = id_mapping, 
    plot_types = "heatmap", 
    force_new_device = FALSE
)
```
# Simulation and benchmarking

DOTSeq includes the function `simDOT()` for generating simulated Ribo-seq 
and RNA-seq count matrices. It enables benchmarking under controlled 
scenarios with configurable effect sizes, batch effects, and ORF types. 

Simulations in [@lim2025differential] show that:

- The **DOU** module performs well at low-to-moderate effect sizes on 
DOU-type scenarios. This module is specifically designed to detect 
condition-dependent shifts in the expected proportion of Ribo-seq to 
RNA-seq counts for individual ORFs relative to other ORFs within the 
same gene* (i.e., changes in ORF usage). This module targets 
*cis*-regulatory usage changes that alter relative ORF proportions 
within genes.

- The **DTE** module performs better at large-magnitude changes in 
translation efficiency. This module captures ORF-level changes in ribosome 
occupancy relative to RNA abundance.

# Summary

DOTSeq offers a unified framework for modelling translational control at 
the ORF level. DOTSeq has two modules capturing distinct biological 
signals: **DOU** tests for shifts in relative usage within genes 
(cis-regulation), whereas **DTE** tests for changes in per-ORF translation 
efficiency relative to transcript abundance. They can be used together to 
provide a fuller picture of translational regulation.

# References

# Session Info
```{r sessionInfo}
sessionInfo()
```

