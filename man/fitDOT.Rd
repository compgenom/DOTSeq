% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fitDOT.R
\name{fitDOT}
\alias{fitDOT}
\title{Fit DOTSeq Differential Translation Models}
\usage{
fitDOT(
  count_table,
  condition_table,
  flattened_gtf,
  bed,
  target = NULL,
  baseline = NULL,
  formula = ~condition * strategy,
  dispersion_modeling = "strategy",
  dispformula = NULL,
  lrt = FALSE,
  diagnostic = FALSE,
  pseudocount = 1e-06,
  min_count = 1,
  stringent = TRUE,
  parallel = list(n = 4L, autopar = TRUE),
  optimizers = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{count_table}{Either a path to a count table file or a data frame.
Must contain columns: Geneid, Chr, Start, End, Strand, Length,
plus one column per sample.}

\item{condition_table}{Either a path to a condition metadata file or a data frame.
Must include columns: run, strategy, condition, replicate.}

\item{flattened_gtf}{Optional path to a flattened GFF/GTF file containing exon definitions.}

\item{bed}{Path to a BED file with ORF annotations.}

\item{target}{Character string specifying the non-reference condition level to extract the corresponding interaction term from the model.
This is contrasted against the baseline condition (default: \code{NULL}).}

\item{baseline}{Character string specifying the desired reference level.}

\item{formula}{A formula object specifying the design, e.g., \code{~ condition * strategy}.}

\item{dispersion_modeling}{Optional string specifying the dispersion modeling strategy.
Used to select between default, constant, or custom dispersion models.}

\item{dispformula}{Optional formula object for custom dispersion modeling.}

\item{lrt}{Logical; if \code{TRUE}, performs a likelihood ratio test to compare the full model (with interaction) against a reduced model
(without interaction) to assess translation-specific effects (default: \code{FALSE}).}

\item{diagnostic}{Logical; if \code{TRUE}, enables model diagnostics including tests for overdispersion,
zero inflation, and residual properties (default: \code{FALSE}).}

\item{pseudocount}{Numeric pseudo-count to avoid division by zero when computing TE (default: \code{1e-6}).}

\item{min_count}{Minimum count threshold for filtering ORFs (default: \code{1}).}

\item{stringent}{Logical or \code{NULL}; determines the filtering strategy:
\describe{
\item{\code{TRUE}}{Keep ORFs where all replicates in at least one condition pass \code{min_count}.}
\item{\code{FALSE}}{Keep ORFs where all replicates in at least one condition-strategy group pass \code{min_count}.}
\item{\code{NULL}}{Keep ORFs where total counts across replicates pass \code{min_count}.}
}}

\item{parallel}{A list passed to \code{glmmTMBControl} to configure parallel optimization.
If \code{NULL}, parallelism is disabled (default: \code{list(n = 4L, autopar = TRUE)}).}

\item{optimizers}{Logical; if \code{TRUE}, enables brute-force optimization using multiple optimizers
in \code{glmmTMB}: \code{nlminb}, \code{bobyqa}, and \code{optim} (default: \code{FALSE}).}

\item{verbose}{Logical; if \code{TRUE}, prints progress messages (default: \code{TRUE}).}
}
\value{
A named \code{list} with the following elements:
\describe{
\item{raw_counts}{Raw counts matrix for all samples.}
\item{norm_counts}{Normalized counts matrix for all samples.}
\item{orfs}{Data frame of ORFs derived from the BED file matched to the DOTSeq object.}
\item{dds}{DESeq2 object used for modeling differential translation efficiency.}
\item{sumExp}{SummarizedExperiment object containing normalized counts and sample metadata.}
\item{dxd}{DOTSeq object used for modeling exon/ORF-level counts.}
\item{formula}{Conditional formula used in \code{DOTSeq::fitDOU}.}
}
}
\description{
This function performs the complete DOTSeq analysis pipeline:
loading count data, aligning with sample metadata, filtering ORFs,
normalizing counts, calculating translational efficiency (TE), and
fitting beta-binomial and negative binomial generalized linear models for
differential ORF translation using \code{DOTSeq::fitDOU} and \code{DESeq2::DESeq}.
}
\examples{
\dontrun{
result <- fitDOT(
  count_table = "counts.txt",
  condition_table = "samples.txt",
  flattened_gtf = "flattened.gff",
  bed = "orfs.bed",
  pseudocount = 1e-6,
  min_count = 1,
  stringent = TRUE,
  verbose = TRUE
)
head(result$sumExp)
}

}
